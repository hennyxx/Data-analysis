# numpy矩阵

##### 创建矩阵

> ==matrix==函数==>创建普通矩阵

```python
np.matrix([[1,2,3],[4,5,6],[7,8,9]])
	[[1 2 3]
     [4 5 6]
     [7 8 9]]
```

> ==mat==函数==>输入对象为**matrix或ndarry**对象，不会创建副本

```python
np.mat("1 2 3;4 5 6;7 8 9")		#用分号隔开(表示分行)
```

> ==bmat==函数==>创建**分块矩阵**(block matrix)

```python
arr1=np.eye(3)					#创建一维数组
	[[1. 0. 0.]
     [0. 1. 0.]
     [0. 0. 1.]]
arr2=3*arr1
	[[3. 0. 0.]
     [0. 3. 0.]
     [0. 0. 3.]]
np.bmat("arr1 arr2;arr1 arr2")	#利用数组进行组合为矩阵
	[[1. 0. 0. 3. 0. 0.]
     [0. 1. 0. 0. 3. 0.]
     [0. 0. 1. 0. 0. 3.]
     [1. 0. 0. 3. 0. 0.]
     [0. 1. 0. 0. 3. 0.]
     [0. 0. 1. 0. 0. 3.]]
```

##### 矩阵运算

```python
matr1=np.mat("1 2 3;4 5 6;7 8 9")	#创建矩阵
	[[1 2 3]
     [4 5 6]
     [7 8 9]]
```

```python
matr2=matr1*3			#矩阵与数相乘(每个元素*数)
	[[ 3  6  9]
     [12 15 18]
     [21 24 27]]
```

```python
matr3=matr1+matr2		#矩阵与矩阵相加(每个对应元素相加)
	[[ 4  8 12]
 	 [16 20 24]
 	 [28 32 36]]
```

```python
matr4=matr1-matr2		#矩阵与矩阵相减(每个对应元素相减)
	[[ -2  -4  -6]
 	 [ -8 -10 -12]
 	 [-14 -16 -18]]
```

```python
matr5=matr1*matr2		#矩阵与矩阵相乘()
	[[ 90 108 126]
 	 [198 243 288]
 	 [306 378 450]]
```

![03-1矩形相乘](C:\Users\16098\Desktop\数据分析\图片\03-1矩形相乘.png)

```python
matr6=np.multiply(matr1,matr2)		#矩阵对应元素相乘
	[[  3,  12,  27],
 	 [ 48,  75, 108],
 	 [147, 192, 243]]
```

> 矩阵特有的属性

| 属性 | 说明                                               |
| :--: | -------------------------------------------------- |
|  T   | 返回自身的转置                                     |
|  H   | 返回自身的共轭矩阵                                 |
|  I   | 返回自身的逆矩阵                                   |
|  A   | 返回自身数据的二维数组的一个视图(没有做任何的复制) |

```python
matr8=np.mat("1 2 3;4 5 6")		
	[[1 2 3]
	 [4 5 6]]
matr8.T		#转置
	[[1 4]
	 [2 5]
	 [3 6]]
```

```python
matr8.H		#共轭转置(实数的共轭就是其本身)
	[[1 4]
	 [2 5]
	 [3 6]]
```

```python
matr8.I		#逆矩阵
	[[-0.94444444,  0.44444444],
	 [-0.11111111,  0.11111111],
	 [ 0.72222222, -0.22222222]]
```

```python
matr8.A		#返回二维数组的视图
array([[1, 2, 3],
       [4, 5, 6]])
```

> ==ufun==函数==>对数组中的**所有元素**进行操作(**四则运算、比较运算、逻辑运算**)
>
> <u>进行四则运算的两个数组必须**形状相同**</u>

前提

```python
x=np.array([1,3,5])
y=np.array([2,3,4])
```

<div align = "center">数组四则运算</div>

```python
x + y		#数组相加
array([3, 6, 9])
x - y		#数组相减
array([-1,  0,  1])
x * y		#数组相乘
array([ 2,  9, 20])
x / y		#数组相除
array([0.5 , 1.  , 1.25])
x ** y		#数组幂运算
array([  1,  27, 625], dtype=int32)		#1**4,2**5,3**6
```

<div align = "center">数组比较运算</div>

```python
x < y		#数组比较
array([ True, False, False])
x > y
array([False, False,  True])
x == y
array([False,  True, False])
x >= y
array([False,  True,  True])
x <= y
array([ True,  True, False])
x != y
array([ True, False,  True])
```

<div align = "center">数组逻辑运算</div>

```python
np.all(x == y)		#np.all()表示逻辑and
	False
np.any(x == y)		#np.any()表示逻辑or
	True
```

### ufunc函数的广播机制